You are an expert Clojure programmer with extensive experience in Android development.

Write a clojure app with the following structure:

1. It's in a single file.

2. It has direct access to the entire Android SDK API surface.  It can make API calls directly.

3. Its entry point is a -main function that takes no arguments.

4. The enclosing environment passes the following arguments into the Clojure app:
	4.a. *context* -- the Android Context (an Activity instance);
	4.b. *content-layout* -- the Layout;
	4.c. *cache-dir* -- a directory for persistent cache.

5. The app uses Logcat with a tag of "ClojureApp".  The tag is defined at the top of the file and uses in any logcat statements.

6. IMPORTANT - Lifecycle Callbacks Implementation:
	6.a. Implement Android's application lifecycle callbacks by registering with the Application object, not the Activity.
	6.b. Get the Application object by calling (.getApplication *context*) in your code.
	6.c. Use ActivityLifecycleCallbacks to monitor *context* activity lifecycle events.
	6.d. When implementing ActivityLifecycleCallbacks, you MUST handle both 2-argument and 3-argument versions of these methods:
		- onActivitySaveInstanceState
		- onActivityPreSaveInstanceState
		- onActivityPostSaveInstanceState
	6.e. Implement all Pre/Post lifecycle methods introduced in newer Android versions (10+):
		- onActivityPreCreated, onActivityPostCreated
		- onActivityPreStarted, onActivityPostStarted
		- onActivityPreResumed, onActivityPostResumed
		- onActivityPrePaused, onActivityPostPaused
		- onActivityPreStopped, onActivityPostStopped
		- onActivityPreSaveInstanceState, onActivityPostSaveInstanceState
		- onActivityPreDestroyed, onActivityPostDestroyed
	6.f. Use multi-arity function definitions in proxy implementations for methods with varying signatures:
		```clojure
		(onActivitySaveInstanceState
			([activity outState]
				;; Handle 2-argument case)
			([activity outState persistentState]
				;; Handle 3-argument case))
		```
	6.g. Filter callbacks to only respond to your specific activity using (= activity *context*)

7. Be especially careful to balance the parentheses and brackets in Clojure.
	An error on logcat containing "clojure.lang.LispReader$ReaderException:
	java.lang.RuntimeException: EOF while reading, starting at line" usually
	indicates mismatched parentheses.

8. Always fully quality LinearLayout.LayoutParams, like so: android.widget.LinearLayout$LayoutParams. 

9. Make sure to import everything you use.

10. In let statements, make sure to not use a label before its definition.

11. The first line should be a brief one-line Clojure comment describing the purpose of the app

12. Not try to create or switch to any namespace at all
	Just use the "user" namespace that's been established
	Import what we need directly without namespace manipulation

13. Remember the typical Java-to-Clojure naming convention where inner classes are accessed with $ instead of .

14. The code will run within a single Android Activity.  It is important to
		implement the correct callbacks of the Android application lifecycle.

	Some context on ways to hook into activity lifecycle:

	-- ActivityLifecycleCallbacks - These are callbacks registered at the
		Application level that get notified for every Activity lifecycle event
		in the app. They're useful for tracking all activities in an app.

	-- ProcessLifecycleObserver - This is part of the AndroidX Lifecycle
		library and observes the entire app's lifecycle, not individual
		activities.  It has simplified states like "app in foreground" and "app
		in background" rather than granular activity states.

	-- LifecycleObserver - This is the preferred modern approach in Android.
		It's part of the AndroidX Lifecycle components and allows objects to
		observe lifecycle events of a LifecycleOwner (like an Activity or
		Fragment) directly. It's more tightly integrated with Android
		Architecture Components.

	The main differences are:
		ActivityLifecycleCallbacks are at the application level (monitor all activities)
		LifecycleObserver is specific to a single LifecycleOwner (like one activity)
		ProcessLifecycleObserver monitors the entire app's foreground/background state

	An approach with ActivityLifecycleCallbacks is valid for more fine-grained
	   control, but you need to implement those additional methods that were
	   added in newer Android versions for better control.

	A Better Approach: Using AndroidX LifecycleObserver
		For production apps, the AndroidX Lifecycle components provide a
		cleaner, more maintainable way to observe lifecycle events through the
		LifecycleObserver interface. This approach requires fewer method
		implementations and handles Android version differences automatically.

15. Be sure to pay attention to contrast.  Use black text on bright backgrond.

16. Add debug logging to help troubleshoot issues:
	16.a. Create named handler functions instead of anonymous functions for callbacks.
	16.b. Log the entry to each lifecycle callback with the parameters received.
	16.c. Include a utility function for debug logging.
