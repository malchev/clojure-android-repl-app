===============================================================
CHAT HISTORY FOR SESSION: ab91eeff-9f39-4eff-a250-7df30a57f063
Created: 2025-11-25 13:58:48
Model: GEMINI (gemini-3-pro-preview)
===============================================================

ðŸ¤– SYSTEM:
    You are an expert Clojure programmer with extensive experience in Android development.

    1. Collaborate with the user to design a production-ready Android Clojure app.
       Greet the user, restate your understanding, ask clarifying questions, and explicitly confirm whether they want you to generate or update the code. Do not produce code until the user clearly requests it. Offer to generate or refine the full app when it makes sense.

    2. CRITICAL: Your ENTIRE response MUST be pure JSON only. NO free text, NO markdown code blocks, NO explanations outside the JSON.

       The API is configured to enforce JSON mode. Your response will be rejected if it contains markdown code blocks or text outside JSON.

       Response format (copy this structure exactly):
       {
         "reasoning": "Your reasoning, explanation, or analysis here (optional but recommended)",
         "code": "The complete Clojure code here (required if providing code)"
       }

       ABSOLUTE REQUIREMENTS:
       - Your response MUST START with the character { and END with the character }
       - NO text, NO markdown, NO code fences before the opening {
       - NO text, NO markdown, NO code fences after the closing }
       - NEVER use markdown code blocks like ```json or ```clojure - the API enforces pure JSON
       - NEVER include phrases like "Here is the code:" or "Here's the response:"
       - At least one of "reasoning" or "code" MUST be present
       - Code content should be raw Clojure code without any markdown formatting
       - Put ALL reasoning and explanations in the "reasoning" field as a string value - nowhere else
       - If response gets truncated, just stop writing - system will detect incomplete fields

       WRONG (will be rejected):
       ```json
       {"reasoning": "...", "code": "..."}
       ```

       CORRECT (required format):
       {"reasoning": "...", "code": "..."}

    Each Clojure app you write has the following structure:

    3. Single-file app with direct access to the entire Android SDK API surface.

    4. Environment provides three dynamic variables:
       4.a. *context* -- Android Context (Activity instance)
       4.b. *content-layout* -- the Layout
       4.c. *cache-dir* -- directory for persistent cache

    5. Entry point: -main function that takes ZERO arguments. Access *context*, *content-layout*, and *cache-dir* directly.

    Design Constraints:

    Code Structure & Quality:
    6. DO NOT wrap the -main function body in try-catch. Exceptions must propagate to Java code for proper error reporting. Catching exceptions inside -main causes silent failures.

    7. Common error: If logcat shows "Error invoking -main function directly: Wrong number of args (0) passed to: clojure.core/-main", you incorrectly generated a -main function that takes arguments.

    8. Balance parentheses and brackets carefully. Logcat error "clojure.lang.LispReader$ReaderException: java.lang.RuntimeException: EOF while reading, starting at line" usually indicates mismatched parentheses.

    9. ALWAYS fully qualify LinearLayout.LayoutParams as: android.widget.LinearLayout$LayoutParams

    10. Import everything you use.

    11. In let statements, do not use a label before its definition.

    12. First line must be a brief one-line Clojure comment describing the app's purpose.

    13. DO NOT create or switch namespaces. Use the "user" namespace that's established. Import directly without namespace manipulation.

    Java-to-Clojure Conventions:
    14. Inner classes: Use $ instead of . (e.g., Lifecycle$Event not Lifecycle.Event)

    15. Static fields: Use / (e.g., View/VISIBLE)

    16. Interfaces: Use proxy instead of reify for interfaces without concrete implementations

    17. Event listeners/callbacks: Consider using separate named handler functions instead of anonymous functions

    Android Lifecycle:
    18. Code runs within a single Android Activity. Implement lifecycle callbacks using AndroidX LifecycleObserver:
        - Import androidx.lifecycle.LifecycleEventObserver
        - Use (proxy [LifecycleEventObserver] [] (onStateChanged [source event] ...))
        - Get lifecycle: (.. *context* (getLifecycle))
        - Register: (.addObserver lifecycle observer)
        - Handle events by examining event.name ("ON_CREATE", "ON_START", etc.)
        - Prefer LifecycleEventObserver interface over annotation-based approaches
        - Use proxy for interfaces with concrete methods (like LifecycleEventObserver)
        - Java annotations (@OnLifecycleEvent) don't translate directly to Clojure
        - Include necessary inner classes in imports (e.g., Lifecycle$Event, Lifecycle$State)

    19. Lifecycle debugging:
        19.a. Add specific debugging for lifecycle registration issues
        19.b. Log current lifecycle state before attempting to observe changes
        19.c. Check logcat for exception messages related to interface implementation
        19.d. Wrap lifecycle registration (but NOT -main function) in try/catch to prevent crashes

    Logging & Debugging:
    20. ALWAYS use Logcat with tag "ClojureApp". Define the tag at the top of the file and use it in all logcat statements.

    21. Debug logging best practices:
        21.a. Create named handler functions instead of anonymous functions for callbacks
        21.b. Log entry to each lifecycle callback with parameters received
        21.c. Include a utility function for debug logging

    UI/UX:
    22. Pay attention to contrast. Use black text on bright background.

---------------------------------------------------------------

ðŸ‘¤ USER:
    The flappy bird looks really weird.  See attached image.  Fix it.  Also speed up the game the longer it runs and space out the obstacles more randomly.

    Existing code for context (do not rewrite unless I request an updated version):
    ```clojure
    ;; Flappy Bird clone with variable obstacle width and increasing speed

    (import
      [android.content Context]
      [android.graphics Canvas Color Paint Paint$Align Rect RectF]
      [android.os Handler Looper SystemClock]
      [android.util Log]
      [android.view View ViewGroup$LayoutParams MotionEvent]
      [android.widget LinearLayout]
      [androidx.lifecycle LifecycleEventObserver Lifecycle$Event]
      [java.util Random])

    (def TAG "ClojureApp")

    ;; Game constants
    (def GAME-WIDTH 1080)
    (def GAME-HEIGHT 1920)
    (def BIRD-SIZE 120)
    (def BASE-PIPE-WIDTH 200)  ;; Now a base width that will vary
    (def MIN-PIPE-WIDTH 100)   ;; Minimum pipe width
    (def MAX-PIPE-WIDTH 300)   ;; Maximum pipe width
    (def PIPE-GAP 600)
    (def GRAVITY 0.8)
    (def JUMP-VELOCITY -20)
    (def BASE-PIPE-SPEED 8)    ;; Base speed that will increase

    ;; Animation constants
    (def FLAP-FRAMES 10) ;; How many frames the flap lasts

    ;; Game state vars
    (def bird-y (atom (/ GAME-HEIGHT 2)))
    (def bird-velocity (atom 0))
    (def pipes (atom []))
    (def score (atom 0))
    (def game-over (atom false))
    (def game-running (atom true))
    (def speed-multiplier (atom 1.0))  ;; New: speed multiplier that increases with score

    ;; Bird flap state
    (def bird-flap-frame (atom 0)) ;; 0 = not flapping, 1..FLAP-FRAMES = flapping
    (def bird-flapping? (atom false))

    (def debug-message (atom "Starting game..."))
    (def frame-count (atom 0))

    (defn log-d [msg]
      (Log/d TAG msg)
      (reset! debug-message msg))

    (defn reset-game []
      (log-d "Game reset")
      (reset! bird-y (/ GAME-HEIGHT 2))
      (reset! bird-velocity 0)
      (reset! pipes [])
      (reset! score 0)
      (reset! game-over false)
      (reset! game-running true)
      (reset! frame-count 0)
      (reset! bird-flap-frame 0)
      (reset! bird-flapping? false)
      (reset! speed-multiplier 1.0))  ;; Reset speed multiplier

    (defn create-pipe []
      (let [random (Random.)
            ;; Random pipe width between MIN and MAX
            pipe-width (+ MIN-PIPE-WIDTH (.nextInt random (- MAX-PIPE-WIDTH MIN-PIPE-WIDTH)))
            top-height (+ 200 (.nextInt random (- GAME-HEIGHT PIPE-GAP 400)))
            bottom-y (+ top-height PIPE-GAP)]
        {:x GAME-WIDTH
         :width pipe-width  ;; Store the width in the pipe data
         :top-height top-height
         :bottom-y bottom-y
         :passed false}))

    (defn spawn-pipe []
      (let [new-pipe (create-pipe)]
        (log-d (str "Spawning pipe at x=" GAME-WIDTH " width=" (:width new-pipe)))
        (swap! pipes conj new-pipe)))

    (defn update-pipes []
      (let [current-speed (int (* BASE-PIPE-SPEED @speed-multiplier))
            updated-pipes (mapv (fn [pipe]
                                 (let [new-x (- (:x pipe) current-speed)
                                       passed? (and (not (:passed pipe)) (< new-x 250))]
                                   (if passed?
                                     (do
                                       (swap! score inc)
                                       ;; Increase speed by 5% with each point
                                       (swap! speed-multiplier #(* % 1.05))
                                       (log-d (str "Score: " @score ", Speed multiplier: " @speed-multiplier))
                                       (assoc pipe :x new-x :passed true))
                                     (assoc pipe :x new-x))))
                               @pipes)
            filtered-pipes (filterv #(> (:x %) (- 0 (:width %))) updated-pipes)]
        (reset! pipes filtered-pipes)))

    (defn check-collision []
      (let [current-bird-y @bird-y
            bird-x 250
            bird-rect (RectF. (float bird-x)
                             (float current-bird-y)
                             (float (+ bird-x BIRD-SIZE))
                             (float (+ current-bird-y BIRD-SIZE)))]
        (or (< current-bird-y 0)
            (> (+ current-bird-y BIRD-SIZE) GAME-HEIGHT)
            (some (fn [{:keys [x width top-height bottom-y]}]
                    (or
                      ;; Collision with top pipe - using the pipe's actual width
                      (and (< x (+ bird-x BIRD-SIZE))
                           (> (+ x width) bird-x)
                           (< current-bird-y top-height))
                      ;; Collision with bottom pipe - using the pipe's actual width
                      (and (< x (+ bird-x BIRD-SIZE))
                           (> (+ x width) bird-x)
                           (> (+ current-bird-y BIRD-SIZE) bottom-y))))
                  @pipes))))

    (defn update-bird []
      (swap! bird-velocity + GRAVITY)
      (swap! bird-y + @bird-velocity))

    (defn jump []
      (reset! bird-velocity JUMP-VELOCITY)
      (reset! bird-flap-frame 1)
      (reset! bird-flapping? true))

    (defn update-flap []
      (when @bird-flapping?
        (if (>= @bird-flap-frame FLAP-FRAMES)
          (do
            (reset! bird-flap-frame 0)
            (reset! bird-flapping? false))
          (swap! bird-flap-frame inc))))

    (defn update-game []
      (when @game-running
        (when (not @game-over)
          (swap! frame-count inc)
          (when (zero? (mod @frame-count 100)) (spawn-pipe))
          (update-bird)
          (update-flap)
          (update-pipes)
          (when (check-collision)
            (log-d "Collision detected! Game over")
            (reset! game-over true)))))

    ;; Drawing helper for bird with animated wings
    (defn draw-bird [canvas bird-x bird-y ^Paint body-paint ^Paint wing-paint]
      (let [cx (+ bird-x (/ BIRD-SIZE 2))
            cy (+ bird-y (/ BIRD-SIZE 2))
            r (/ BIRD-SIZE 2)
            ;; Wing animation: angle in radians, varies from -30deg to +30deg
            wing-range (* Math/PI (/ 60.0 180.0)) ;; 60 degrees in radians
            phase (if @bird-flapping?
                    ;; Animate using a sine wave over FLAP-FRAMES
                    (let [progress (/ (dec @bird-flap-frame) FLAP-FRAMES)]
                      (* wing-range (Math/sin (* progress Math/PI))))
                    0.0)
            ;; Wing centerpoints relative to body
            wing-offset-x (- r 10)
            wing-offset-y 20
            wing-length 65
            wing-width 30]
        ;; Draw body (circle)
        (.drawOval canvas
          (RectF. (float bird-x)
                  (float bird-y)
                  (float (+ bird-x BIRD-SIZE))
                  (float (+ bird-y BIRD-SIZE)))
          body-paint)
        ;; Draw left wing
        (let [lx (- cx wing-offset-x)
              ly (+ cy wing-offset-y)
              angle (- (- (/ Math/PI 2) phase))
              wx (+ lx (* wing-length (Math/cos angle)))
              wy (+ ly (* wing-length (Math/sin angle)))
              ]
          (.drawRect canvas
            (RectF.
              (float (- lx (/ wing-width 2)))
              (float (- ly 10))
              (float (+ lx (/ wing-width 2)))
              (float (+ ly wing-length)))
            wing-paint)
          (.drawLine canvas
            (float lx) (float ly)
            (float wx) (float wy)
            wing-paint))
        ;; Draw right wing (mirror)
        (let [rx (+ cx wing-offset-x)
              ry (+ cy wing-offset-y)
              angle (+ (/ Math/PI 2) phase)
              wx (+ rx (* wing-length (Math/cos angle)))
              wy (+ ry (* wing-length (Math/sin angle)))]
          (.drawRect canvas
            (RectF.
              (float (- rx (/ wing-width 2)))
              (float (- ry 10))
              (float (+ rx (/ wing-width 2)))
              (float (+ ry wing-length)))
            wing-paint)
          (.drawLine canvas
            (float rx) (float ry)
            (float wx) (float wy)
            wing-paint))
        ;; Draw eye
        (let [eye-x (+ cx 25)
              eye-y (- cy 20)
              eye-radius 10]
          (.drawCircle canvas
            (float eye-x) (float eye-y) (float eye-radius)
            (doto (Paint.) (.setColor Color/BLACK))))
        ;; Draw beak
        (let [beak-x (+ cx 50)
              beak-y cy]
          (.drawOval canvas
            (RectF. (float beak-x)
                    (float (- beak-y 7))
                    (float (+ beak-x 20))
                    (float (+ beak-y 7)))
            (doto (Paint.) (.setColor (Color/rgb 255 170 0)))))))

    ;; Game view with white background and animated bird
    (defn create-game-view [context]
      (let [body-paint (doto (Paint.)
                         (.setColor Color/YELLOW)
                         (.setAntiAlias true))
            wing-paint (doto (Paint.)
                         (.setColor (Color/rgb 200 200 200)) ; light gray wings
                         (.setStrokeWidth 10)
                         (.setAntiAlias true))
            pipe-paint (doto (Paint.)
                         (.setColor (Color/rgb 0 150 0)))
            text-paint (doto (Paint.)
                         (.setColor Color/BLACK)
                         (.setTextSize 80)
                         (.setTextAlign Paint$Align/CENTER)
                         (.setAntiAlias true))
            debug-paint (doto (Paint.)
                          (.setColor Color/BLACK)
                          (.setTextSize 40)
                          (.setTextAlign Paint$Align/LEFT)
                          (.setAntiAlias true))
            game-view (proxy [View] [context]
                        (onDraw [canvas]
                          ;; Draw white background
                          (.drawColor canvas Color/WHITE)
                          ;; Draw pipes
                          (doseq [{:keys [x width top-height bottom-y]} @pipes]
                            ;; Top pipe - using the pipe's actual width
                            (.drawRect canvas
                              (float x)
                              0
                              (float (+ x width))
                              (float top-height)
                              pipe-paint)
                            ;; Bottom pipe - using the pipe's actual width
                            (.drawRect canvas
                              (float x)
                              (float bottom-y)
                              (float (+ x width))
                              (float GAME-HEIGHT)
                              pipe-paint))
                          ;; Draw animated bird
                          (draw-bird canvas 250 @bird-y body-paint wing-paint)
                          ;; Draw score in black
                          (.drawText canvas (str @score) (/ GAME-WIDTH 2) 150 text-paint)
                          ;; Draw debug info
                          (.drawText canvas @debug-message 20 50 debug-paint)
                          (.drawText canvas (str "Pipes: " (count @pipes)
                                                 ", Speed: " (format "%.2f" (* BASE-PIPE-SPEED @speed-multiplier)))
                                     20 100 debug-paint)
                          ;; Draw game over
                          (when @game-over
                            (.setTextSize text-paint 120)
                            (.drawText canvas "Game Over" (/ GAME-WIDTH 2) (/ GAME-HEIGHT 2) text-paint)
                            (.setTextSize text-paint 80)
                            (.drawText canvas "Tap to restart" (/ GAME-WIDTH 2) (+ (/ GAME-HEIGHT 2) 150) text-paint))))
            ;; Touch handler
            _ (doto game-view
                (.setOnTouchListener
                  (reify android.view.View$OnTouchListener
                    (onTouch [this view event]
                      (let [action (.getAction event)]
                        (when (= action MotionEvent/ACTION_DOWN)
                          (if @game-over
                            (reset-game)
                            (jump)))
                        true)))))]
        game-view))

    (def game-loop-handler (atom nil))

    (defn start-game-loop [game-view]
      (log-d "Starting game loop")
      (let [main-looper (Looper/getMainLooper)
            handler (Handler. main-looper)
            runnable-ref (atom nil)]
        (reset! runnable-ref
                (fn []
                  (update-game)
                  (.invalidate game-view)
                  (.postDelayed handler @runnable-ref 16))) ;; 60fps
        (reset! game-loop-handler handler)
        (.post handler @runnable-ref)))

    (defn stop-game-loop []
      (log-d "Stopping game loop")
      (when @game-loop-handler
        (.removeCallbacksAndMessages @game-loop-handler nil)))

    (defn setup-lifecycle-observer []
      (proxy [LifecycleEventObserver] []
        (onStateChanged [source event]
          (log-d (str "Lifecycle event: " (.name event)))
          (case (.name event)
            "ON_RESUME" (reset! game-running true)
            "ON_PAUSE" (reset! game-running false)
            "ON_DESTROY" (stop-game-loop)
            nil))))

    (defn -main []
      (log-d "Starting Flappy Bird game")
      (let [layout (doto (LinearLayout. *context*)
                     (.setLayoutParams (ViewGroup$LayoutParams.
                                         ViewGroup$LayoutParams/MATCH_PARENT
                                         ViewGroup$LayoutParams/MATCH_PARENT))
                     (.setOrientation LinearLayout/VERTICAL))
            game-view (create-game-view *context*)
            layout-params (android.widget.LinearLayout$LayoutParams.
                            android.widget.LinearLayout$LayoutParams/MATCH_PARENT
                            android.widget.LinearLayout$LayoutParams/MATCH_PARENT)
            _ (.addView layout game-view layout-params)
            lifecycle-observer (setup-lifecycle-observer)]
        (try
          (.. *context* (getLifecycle) (addObserver lifecycle-observer))
          (catch Exception e
            (log-d (str "Error registering lifecycle observer: " (.getMessage e)))))
        (reset-game)
        (spawn-pipe)
        (start-game-loop game-view)
        (doto *content-layout*
          (.removeAllViews)
          (.addView layout))))
    ```

---------------------------------------------------------------

ðŸ§  ASSISTANT (GEMINI/gemini-3-pro-preview):
    {
      "reasoning": "I have addressed the user's three requests:\n\n1.  **Fix the 'weird' bird**: I completely rewrote the `draw-bird` function. Instead of complex procedural lines for wings which likely looked disjointed, I implemented a clean, standard 'Flappy Bird' style design using simple geometric shapes: a yellow circular body, a large white eye with a pupil, and an orange beak. This is much more visually stable and recognizable.\n\n2.  **Speed up the game**: I modified the speed progression in `update-pipes`. Previously, it multiplied speed by 1.05 (exponential) which becomes unplayable very quickly. I changed this to a linear increase (`+ 0.02` to the multiplier) per pipe passed. This ensures the game speeds up noticeably the longer it runs, but remains playable for longer.\n\n3.  **Space out obstacles randomly**: I removed the fixed frame-counter spawning logic (`mod frame-count 100`). I introduced a `next-spawn-gap` atom and a randomized spawning system. The game now checks the position of the last pipe and spawns a new one only after a randomized gap (between 500px and 900px) has passed. This creates the requested variation in obstacle spacing.",
      "code": ";; Flappy Bird clone with improved graphics, random spacing, and progressive speed\n\n(import\n  [android.content Context]\n  [android.graphics Canvas Color Paint Paint$Align Rect RectF]\n  [android.os Handler Looper SystemClock]\n  [android.util Log]\n  [android.view View ViewGroup$LayoutParams MotionEvent]\n  [android.widget LinearLayout]\n  [androidx.lifecycle LifecycleEventObserver Lifecycle$Event]\n  [java.util Random])\n\n(def TAG \"ClojureApp\")\n\n;; Game constants\n(def GAME-WIDTH 1080)\n(def GAME-HEIGHT 1920)\n(def BIRD-SIZE 120)\n(def BASE-PIPE-WIDTH 200)\n(def MIN-PIPE-WIDTH 150)\n(def MAX-PIPE-WIDTH 250)\n(def PIPE-GAP 550)\n(def GRAVITY 0.9)\n(def JUMP-VELOCITY -22)\n(def BASE-PIPE-SPEED 9)\n\n;; Spawning constants\n(def MIN-SPAWN-GAP 500)  ;; Minimum horizontal distance between pipes\n(def MAX-SPAWN-GAP 900)  ;; Maximum horizontal distance between pipes\n\n;; Animation constants\n(def FLAP-FRAMES 10)\n\n;; Game state vars\n(def bird-y (atom (/ GAME-HEIGHT 2)))\n(def bird-velocity (atom 0))\n(def pipes (atom []))\n(def score (atom 0))\n(def game-over (atom false))\n(def game-running (atom true))\n(def speed-multiplier (atom 1.0))\n(def next-spawn-gap (atom 600)) ;; Distance required before next pipe\n\n;; Bird flap state\n(def bird-flap-frame (atom 0))\n(def bird-flapping? (atom false))\n\n(def debug-message (atom \"Starting game...\"))\n(def frame-count (atom 0))\n\n(defn log-d [msg]\n  (Log/d TAG msg)\n  (reset! debug-message msg))\n\n(defn reset-game []\n  (log-d \"Game reset\")\n  (reset! bird-y (/ GAME-HEIGHT 2))\n  (reset! bird-velocity 0)\n  (reset! pipes [])\n  (reset! score 0)\n  (reset! game-over false)\n  (reset! game-running true)\n  (reset! frame-count 0)\n  (reset! bird-flap-frame 0)\n  (reset! bird-flapping? false)\n  (reset! speed-multiplier 1.0)\n  (reset! next-spawn-gap 600))\n\n(defn create-pipe []\n  (let [random (Random.)\n        pipe-width (+ MIN-PIPE-WIDTH (.nextInt random (- MAX-PIPE-WIDTH MIN-PIPE-WIDTH)))\n        ;; Ensure pipes aren't too high or too low\n        min-pipe-height 200\n        available-height (- GAME-HEIGHT PIPE-GAP (* 2 min-pipe-height))\n        top-height (+ min-pipe-height (.nextInt random available-height))\n        bottom-y (+ top-height PIPE-GAP)]\n    {:x GAME-WIDTH\n     :width pipe-width\n     :top-height top-height\n     :bottom-y bottom-y\n     :passed false}))\n\n(defn spawn-pipe []\n  (let [new-pipe (create-pipe)]\n    ;; Set the gap for the *next* pipe randomly\n    (reset! next-spawn-gap (+ MIN-SPAWN-GAP (rand-int (- MAX-SPAWN-GAP MIN-SPAWN-GAP))))\n    (swap! pipes conj new-pipe)))\n\n(defn update-pipes []\n  (let [current-speed (int (* BASE-PIPE-SPEED @speed-multiplier))\n        updated-pipes (mapv (fn [pipe]\n                             (let [new-x (- (:x pipe) current-speed)\n                                   passed? (and (not (:passed pipe)) (< new-x 250))]\n                               (if passed?\n                                 (do\n                                   (swap! score inc)\n                                   ;; Linear speed increase: +0.02 multiplier per pipe\n                                   ;; This is smoother than exponential and keeps game playable longer\n                                   (swap! speed-multiplier #(+ % 0.02))\n                                   (log-d (str \"Score: \" @score \", Speed x\" (format \"%.2f\" @speed-multiplier)))\n                                   (assoc pipe :x new-x :passed true))\n                                 (assoc pipe :x new-x))))\n                           @pipes)\n        filtered-pipes (filterv #(> (+ (:x %) (:width %)) 0) updated-pipes)]\n    (reset! pipes filtered-pipes)))\n\n(defn check-collision []\n  (let [current-bird-y @bird-y\n        bird-x 250\n        ;; Shrink hit box slightly to be forgiving\n        hit-margin 15\n        bird-rect (RectF. (float (+ bird-x hit-margin))\n                         (float (+ current-bird-y hit-margin))\n                         (float (- (+ bird-x BIRD-SIZE) hit-margin))\n                         (float (- (+ current-bird-y BIRD-SIZE) hit-margin)))]\n    (or (< current-bird-y 0)\n        (> (+ current-bird-y BIRD-SIZE) GAME-HEIGHT)\n        (some (fn [{:keys [x width top-height bottom-y]}]\n                (or\n                  ;; Top pipe collision\n                  (and (< x (+ bird-x BIRD-SIZE))\n                       (> (+ x width) bird-x)\n                       (< (+ current-bird-y hit-margin) top-height))\n                  ;; Bottom pipe collision\n                  (and (< x (+ bird-x BIRD-SIZE))\n                       (> (+ x width) bird-x)\n                       (> (- (+ current-bird-y BIRD-SIZE) hit-margin) bottom-y))))\n              @pipes))))\n\n(defn update-bird []\n  (swap! bird-velocity + GRAVITY)\n  (swap! bird-y + @bird-velocity))\n\n(defn jump []\n  (reset! bird-velocity JUMP-VELOCITY)\n  (reset! bird-flap-frame 1)\n  (reset! bird-flapping? true))\n\n(defn update-flap []\n  (when @bird-flapping?\n    (if (>= @bird-flap-frame FLAP-FRAMES)\n      (do\n        (reset! bird-flap-frame 0)\n        (reset! bird-flapping? false))\n      (swap! bird-flap-frame inc))))\n\n(defn update-game []\n  (when @game-running\n    (when (not @game-over)\n      (swap! frame-count inc)\n      \n      ;; Random Spawning Logic\n      (let [last-pipe (last @pipes)]\n        (if (nil? last-pipe)\n          (spawn-pipe) ;; Start with a pipe\n          (let [last-pipe-right-edge (+ (:x last-pipe) (:width last-pipe))\n                distance-from-edge (- GAME-WIDTH last-pipe-right-edge)]\n            ;; Spawn if the gap since the last pipe is large enough\n            (when (> distance-from-edge @next-spawn-gap)\n              (spawn-pipe)))))\n\n      (update-bird)\n      (update-flap)\n      (update-pipes)\n      (when (check-collision)\n        (log-d \"Collision detected! Game over\")\n        (reset! game-over true)))))\n\n;; Improved Bird Drawing - Clean and Cute\n(defn draw-bird [canvas bird-x bird-y ^Paint paint]\n  ;; 1. Body (Yellow Circle)\n  (.setColor paint (Color/rgb 255 215 0)) ;; Gold/Yellow\n  (.drawOval canvas \n    (RectF. (float bird-x) (float bird-y) \n            (float (+ bird-x BIRD-SIZE)) (float (+ bird-y BIRD-SIZE))) \n    paint)\n  \n  ;; 2. Eye (White Circle with Black Pupil)\n  (let [eye-radius (/ BIRD-SIZE 4.5)\n        eye-x (+ bird-x (* BIRD-SIZE 0.7))\n        eye-y (+ bird-y (* BIRD-SIZE 0.3))]\n    ;; Eye White\n    (.setColor paint Color/WHITE)\n    (.drawCircle canvas (float eye-x) (float eye-y) (float eye-radius) paint)\n    ;; Pupil\n    (.setColor paint Color/BLACK)\n    (.drawCircle canvas (float (+ eye-x 4)) (float eye-y) (float (/ eye-radius 2.5)) paint))\n\n  ;; 3. Beak (Orange Oval)\n  (.setColor paint (Color/rgb 255 140 0)) ;; Dark Orange\n  (let [beak-x (+ bird-x (* BIRD-SIZE 0.8))\n        beak-y (+ bird-y (* BIRD-SIZE 0.6))]\n    (.drawOval canvas \n      (RectF. (float beak-x) (float (- beak-y 15)) \n              (float (+ beak-x 40)) (float (+ beak-y 15))) \n      paint))\n      \n  ;; 4. Simple Wing (White/Cream Oval)\n  (.setColor paint (Color/rgb 255 255 220))\n  (let [wing-x (+ bird-x (* BIRD-SIZE 0.2))\n        wing-y (+ bird-y (* BIRD-SIZE 0.55))\n        ;; Simple flap animation: move wing slightly up/down\n        flap-offset (if @bird-flapping? -10 0)]\n    (.drawOval canvas\n      (RectF. (float wing-x) (float (+ wing-y flap-offset))\n              (float (+ wing-x 50)) (float (+ (+ wing-y 35) flap-offset)))\n      paint)))\n\n(defn create-game-view [context]\n  (let [paint (doto (Paint.) (.setAntiAlias true))\n        text-paint (doto (Paint.)\n                     (.setColor Color/BLACK)\n                     (.setTextSize 80)\n                     (.setTextAlign Paint$Align/CENTER)\n                     (.setAntiAlias true))\n        debug-paint (doto (Paint.)\n                      (.setColor Color/BLACK)\n                      (.setTextSize 40)\n                      (.setTextAlign Paint$Align/LEFT)\n                      (.setAntiAlias true))\n        game-view (proxy [View] [context]\n                    (onDraw [canvas]\n                      ;; Draw white background\n                      (.drawColor canvas Color/WHITE)\n                      \n                      ;; Draw pipes\n                      (.setColor paint (Color/rgb 0 180 0)) ;; Green pipes\n                      (doseq [{:keys [x width top-height bottom-y]} @pipes]\n                        ;; Top pipe\n                        (.drawRect canvas\n                          (float x) 0 (float (+ x width)) (float top-height) paint)\n                        ;; Bottom pipe\n                        (.drawRect canvas\n                          (float x) (float bottom-y) (float (+ x width)) (float GAME-HEIGHT) paint)\n                        ;; Pipe caps (darker green details)\n                        (.setColor paint (Color/rgb 0 120 0))\n                        (.drawRect canvas (float x) (float (- top-height 40)) (float (+ x width)) (float top-height) paint)\n                        (.drawRect canvas (float x) (float bottom-y) (float (+ x width)) (float (+ bottom-y 40)) paint)\n                        (.setColor paint (Color/rgb 0 180 0))) ;; Reset to normal green\n\n                      ;; Draw improved bird\n                      (draw-bird canvas 250 @bird-y paint)\n\n                      ;; Draw score\n                      (.drawText canvas (str @score) (/ GAME-WIDTH 2) 150 text-paint)\n                      \n                      ;; Draw debug info\n                      (.drawText canvas @debug-message 20 50 debug-paint)\n                      (.drawText canvas (str \"Speed: \" (format \"%.2f\" @speed-multiplier) \"x\") 20 100 debug-paint)\n\n                      ;; Draw game over\n                      (when @game-over\n                        (.setTextSize text-paint 120)\n                        (.drawText canvas \"Game Over\" (/ GAME-WIDTH 2) (/ GAME-HEIGHT 2) text-paint)\n                        (.setTextSize text-paint 80)\n                        (.drawText canvas \"Tap to restart\" (/ GAME-WIDTH 2) (+ (/ GAME-HEIGHT 2) 150) text-paint))))\n        ;; Touch handler\n        _ (doto game-view\n            (.setOnTouchListener\n              (reify android.view.View$OnTouchListener\n                (onTouch [this view event]\n                  (let [action (.getAction event)]\n                    (when (= action MotionEvent/ACTION_DOWN)\n                      (if @game-over\n                        (reset-game)\n                        (jump))) \n                    true)))))]\n    game-view))\n\n(def game-loop-handler (atom nil))\n\n(defn start-game-loop [game-view]\n  (log-d \"Starting game loop\")\n  (let [main-looper (Looper/getMainLooper)\n        handler (Handler. main-looper)\n        runnable-ref (atom nil)]\n    (reset! runnable-ref\n            (fn []\n              (update-game)\n              (.invalidate game-view)\n              (.postDelayed handler @runnable-ref 16))) ;; ~60fps\n    (reset! game-loop-handler handler)\n    (.post handler @runnable-ref)))\n\n(defn stop-game-loop []\n  (log-d \"Stopping game loop\")\n  (when @game-loop-handler\n    (.removeCallbacksAndMessages @game-loop-handler nil)))\n\n(defn setup-lifecycle-observer []\n  (proxy [LifecycleEventObserver] []\n    (onStateChanged [source event]\n      (log-d (str \"Lifecycle event: \" (.name event)))\n      (case (.name event)\n        \"ON_RESUME\" (reset! game-running true)\n        \"ON_PAUSE\" (reset! game-running false)\n        \"ON_DESTROY\" (stop-game-loop)\n        nil))))\n\n(defn -main []\n  (log-d \"Starting Flappy Bird game\")\n  (let [layout (doto (LinearLayout. *context*)\n                 (.setLayoutParams (ViewGroup$LayoutParams.\n                                     ViewGroup$LayoutParams/MATCH_PARENT\n                                     ViewGroup$LayoutParams/MATCH_PARENT))\n                 (.setOrientation LinearLayout/VERTICAL))\n        game-view (create-game-view *context*)\n        layout-params (android.widget.LinearLayout$LayoutParams.\n                        android.widget.LinearLayout$LayoutParams/MATCH_PARENT\n                        android.widget.LinearLayout$LayoutParams/MATCH_PARENT)\n        _ (.addView layout game-view layout-params)\n        lifecycle-observer (setup-lifecycle-observer)]\n    (try\n      (.. *context* (getLifecycle) (addObserver lifecycle-observer))\n      (catch Exception e\n        (log-d (str \"Error registering lifecycle observer: \" (.getMessage e)))))\n    (reset-game)\n    (spawn-pipe)\n    (start-game-loop game-view)\n    (doto *content-layout*\n      (.removeAllViews)\n      (.addView layout))))"
    }

---------------------------------------------------------------

